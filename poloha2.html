<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Leaflet + GeoEvent Stream — šipky s outline a číslem</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>html,body,#map{height:100%;margin:0} .controls{position:fixed;z-index:1000;padding:8px;}</style>
</head>
<body>
<div class="controls">
    <button id="startBtn">Start sledování</button>
    <button id="stopBtn" disabled>Stop</button>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>




    const stopsMap = new Map(); // id -> název

    // Načte stops.csv z totéhož adresáře a naplní stopsMap.
    // Očekává CSV se dvěma sloupci: id,nazev (první řádek není header; toleruje header i bez něj)
    async function loadStopsCsv(url = 'stops.csv') {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error('Failed to fetch stops.csv');
            const txt = await res.text();
            const lines = txt.split(/\r?\n/);
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                // jednoduché CSV split na první čárku (pokud název může obsahovat čárky, upravte parser)
                const idx = line.indexOf(';');
                if (idx === -1) continue;
                const id = line.slice(0, idx).trim();
                const name = line.slice(idx + 1).trim();
                if (!id) continue;
                stopsMap.set(id, name);
            }
            console.log('Loaded stops:', stopsMap.size);
        } catch (e) {
            console.warn('Could not load stops.csv:', e);
        }
    }



    loadStopsCsv();





    const map = L.map('map').setView([49.1951, 16.6068], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OSM' }).addTo(map);

    let ws = null;
    let tracking = false;
    const vehicles = new Map();
    const STREAM_URL = 'wss://gis.brno.cz/geoevent/ws/services/stream_kordis_26/StreamServer/subscribe';

    // Barva podle LineID
    function colorForLine(lineId, vtype, isInactive) {
        const id = Number(lineId) || 0;
        const vt = Number(vtype);
        if (vt == 5) return '#c66b4b';
        if (isInactive) return '#ffffff';
        if (id >= 1 && id <= 20) return '#d32d2a';       // červená
        if (id >= 21 && id <= 39) return '#4ca14c';      // zelená
        if (id >= 40 && id <= 88) return '#247ac8';      // modrá
        if (id >= 89 && id <= 99) return '#000000';      // černá
        if (id >= 100 && id <= 999) return '#878686';    // tmavě šedá
        return '#1978c8';
    }

    // SVG trojúhelník s bílým outline (stroke) a číslem linky nezávislým na rotaci
    function createTriangleHtml(bearing=0, size=36, fillColor='#1978c8', lineText='') {
        const half = size / 2;
        // trojúhelník orientovaný špičkou nahoru; polygon má bílý stroke pro outline
        // číslo linky vložíme jako <text> s opačnou rotací (rotate(-bearing)) tak, aby zůstalo rovné
        // ale protože text uvnitř rotovaného wrapperu by se také rotoval, vytvoříme dvě vrstvy:
        // - wrapper s rotací pro SVG trojúhelník
        // - nad ním absolutně pozicovaný text bez rotace
        const svg = `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
        <polygon points="${half},2 ${size-2},${size-2} 2,${size-2}"
                 fill="${fillColor}" stroke="#ffffff" stroke-width="2" />
      </svg>
    `;
        const textHtml = lineText ? `<div style="position:absolute;left:0;top:68%;width:${size}px;margin-top:-0.6em;text-align:center;font-weight:700;color:#ffffff;font-size:${Math.floor(size/3.4)}px;text-shadow:0 0 2px rgba(0,0,0,0.5);pointer-events:none;">${lineText}</div>` : '';
        const wrapper = `
      <div style="position:relative; width:${size}px; height:${size}px; display:inline-block; transform: rotate(${bearing}deg);">
        ${svg}
        ${textHtml}
      </div>
    `;
        return wrapper;
    }

    // vytvoří L.divIcon
    function createTriangleIcon(bearing=0, size=36, fillColor='#1978c8', lineText='') {
        const html = createTriangleHtml(bearing, size, fillColor, lineText);
        return L.divIcon({
            html,
            className: '',
            iconSize: [size, size],
            iconAnchor: [size/2, size/2]
        });
    }

    // aktualizace ikony u existujícího markeru (přehození na novou divIcon)
    function updateMarkerIcon(marker, bearing, lineId, lineName, size=36) {
        const color = colorForLine(lineId, vtype, isInactive);
        const txt = (lineName !== undefined && lineName !== null) ? String(lineName) : '';
        const newIcon = createTriangleIcon(bearing, size, color, txt);
        marker.setIcon(newIcon);
    }

    // --- Zpracování dat (stejné jako dříve) ---
    function handleMessage(msgText) {
        try {
            const obj = JSON.parse(msgText);
            if (Array.isArray(obj)) obj.forEach(processEnvelope);
            else processEnvelope(obj);
        } catch (e) {
            msgText.trim().split(/\r?\n/).forEach(line => {
                if (!line) return;
                try { const o = JSON.parse(line); if (Array.isArray(o)) o.forEach(processEnvelope); else processEnvelope(o); }
                catch(err){ /* ignore */ }
            });
        }
    }

    function processEnvelope(envelope) {
        if (!envelope) return;
        const rec = envelope.attributes || envelope;
        processRecord(rec);
    }

    function processRecord(record) {
        if (!record || typeof record.ID === 'undefined') return;
        const id = String(record.ID);
        const isInactive = (record.IsInactive === "true" || record.IsInactive === true);
        //if (isInactive || record.Lat == null || record.Lng == null) {
        //    const m = vehicles.get(id);
        //    if (m) { map.removeLayer(m); vehicles.delete(id); }
        //    return;
        //}
        const lat = Number(record.Lat);
        const lng = Number(record.Lng);
        const bearing = Number(record.Bearing || 0);
        const lineId = record.LineID;
        const lineName = record.LineName;
        const vtype = record.VType;





        const rawFinalStop = record.FinalStopID != null ? String(record.FinalStopID) : '';
        const finalStopName = stopsMap.get(rawFinalStop) || rawFinalStop || '';
        const popup = `Linka: ${record.LineName || lineId || ''} ( ${record.Course} )<br>Do: ${finalStopName} <br>Zpoždění: ${record.Delay} min.`;









        //const popup = `Linka: ${record.LineName || lineId || ''} ( ${record.Course} )<br>Do: ${record.FinalStopID} <br>Zpoždění: ${record.Delay} min.`;

        if (vehicles.has(id)) {
            const marker = vehicles.get(id);
            marker.setLatLng([lat, lng]);
            updateMarkerIcon(marker, bearing, lineID, lineName);
            if (marker.getPopup()) marker.setPopupContent(popup);
        } else {
            const icon = createTriangleIcon(bearing, 36, colorForLine(lineId, vtype, isInactive), lineName !== undefined ? String(lineName) : '');
            const marker = L.marker([lat, lng], {icon});
            marker.bindPopup(popup);
            marker.addTo(map);
            vehicles.set(id, marker);
        }
    }

    // --- Filter a WS ---
    function sendFilter(wsInstance, lineFilter = null) {
        if (!wsInstance || wsInstance.readyState !== WebSocket.OPEN) return;
        const where = lineFilter ? `LineID = ${Number(lineFilter)}` : "1=1";
        const filter = {
            filter: {
                where: where,
                outFields: "ID,Lat,Lng,Bearing,LineID,LineName,IsInactive,FinalStopID,VType,Course,Delay"
            }
        };
        wsInstance.send(JSON.stringify(filter));
    }

    function startWebsocket(lineFilter = null) {
        if (ws) return;
        ws = new WebSocket(STREAM_URL);
        ws.addEventListener('open', () => { sendFilter(ws, lineFilter); });
        ws.addEventListener('message', ev => {
            if (typeof ev.data === 'string') handleMessage(ev.data);
            else {
                const reader = new FileReader();
                reader.onload = () => handleMessage(reader.result);
                reader.readAsText(ev.data);
            }
        });
        ws.addEventListener('close', () => { ws = null; });
        ws.addEventListener('error', () => { /* ignore */ });
    }

    function stopWebsocket() {
        if (!ws) return;
        try { ws.close(); } catch(e) {}
        ws = null;
    }

    // --- UI ---
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');

    startBtn.addEventListener('click', () => {
        if (tracking) return;
        tracking = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        startWebsocket();
    });

    stopBtn.addEventListener('click', () => {
        if (!tracking) return;
        tracking = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        stopWebsocket();
        for (const m of vehicles.values()) map.removeLayer(m);
        vehicles.clear();
    });
</script>
</body>
</html>
